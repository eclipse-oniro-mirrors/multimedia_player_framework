/*
 * Copyright (C) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@!namespace("multimedia.soundPool")

@!sts_inject("""
import { BusinessError, ErrorCallback, AsyncCallback, Callback } from '@ohos.base';
""")

use ohos.multimedia.audio as audio;

struct PlayParameters {
  loop: Optional<i32>;
  rate: Optional<i32>;
  leftVolume: Optional<f64>;
  rightVolume: Optional<f64>;
  priority: Optional<i32>;
  parallelPlayFlag: Optional<bool>;
}

enum ErrorType: i32 {
    LOAD_ERROR = 1,
    PLAY_ERROR = 2
}

enum InterruptMode: i32 {
    NO_INTERRUPT = 0,
    SAME_SOUND_INTERRUPT = 1
}

@!sts_inject("""
export interface ErrorInfo<T extends Error = BusinessError> {
    errorCode: T;
    errorType?: ErrorType;
    soundId?: int;
    streamId?: int;
}

class _taihe_ErrorInfo_inject implements ErrorInfo {
    errorCode: BusinessError<void>;
    errorType: (ErrorType | undefined);
    soundId: (int | undefined);
    streamId: (int | undefined);
    constructor(
        errorCode: BusinessError<void>,
        errorType: (ErrorType | undefined),
        soundId: (int | undefined),
        streamId: (int | undefined),
    )
    {
        this.errorCode = errorCode;
        this.errorType = errorType;
        this.soundId = soundId;
        this.streamId = streamId;
    }
}
""")

interface SoundPool {
    @gen_async("load")
    @gen_promise("load")
    LoadSync(uri: String): i32;

    @gen_async("load")
    @gen_promise("load")
    LoadWithFdSync(fd: i32, offset: i64, length: i64): i32;

    @gen_promise("play")
    PlaySync(soundID: i32, params: Optional<PlayParameters>): i32;

    @gen_async("play")
    PlayWithoutParam(soundID: i32): i32;

    @gen_async("play")
    PlayWithParam(soundID: i32, params: PlayParameters): i32;

    @gen_async("stop")
    @gen_promise("stop")
    StopSync(streamID: i32): void;

    @gen_async("setLoop")
    @gen_promise("setLoop")
    SetLoopSync(streamID: i32, loop: i32): void;

    @gen_async("setRate")
    @gen_promise("setRate")
    SetRateSync(streamID: i32, rate: audio.AudioRendererRate): void;

    @gen_async("setPriority")
    @gen_promise("setPriority")
    SetPrioritySync(streamID: i32, priority: i32): void;

    @gen_async("setVolume")
    @gen_promise("setVolume")
    SetVolumeSync(streamID: i32, leftVolume: f64, rightVolume: f64): void;

    SetInterruptMode(interruptMode: InterruptMode): void;

    @gen_async("unload")
    @gen_promise("unload")
    UnloadSync(soundID: i32): void;

    @gen_async("release")
    @gen_promise("release")
    ReleaseSync(): void;

    @!sts_inject_into_interface("on(type: string, callback: (data: object)=> void): void;")
    @!sts_inject_into_class("""on(type: string, callback: object): void {
        if (type === "playFinishedWithStreamId") {
            this.onPlayFinishedWithStreamId(callback as (data: int)=> void);
        } else if (type === "error") {
            this.onError(callback as (err: BusinessError<void>)=> void);
        } else if (type === "loadComplete") {
            this.onLoadComplete(callback as (data: int)=> void);
        } else if (type === "playFinished") {
            this.onPlayFinished(callback as (data: undefined)=> void);
        } else if (type === "errorOccurred") {
            this.onErrorOccurred(callback as (data: ErrorInfo)=> void);
        } else {
            throw new Error(`Unknown type: ${type}`);
        }
    }""")

    @!sts_inject_into_interface("off(type: string): void;")
    @!sts_inject_into_class("""off(type: string): void {
        if (type === "playFinishedWithStreamId") {
            this.offPlayFinishedWithStreamId();
        } else if (type === "error") {
            this.offError();
        } else if (type === "loadComplete") {
            this.offLoadComplete();
        } else if (type === "playFinished") {
            this.offPlayFinished();
        } else {
            throw new Error(`Unknown type: ${type}`);
        }
    }""")

    @!sts_inject_into_interface("off(type: string, callback?: (data: object)=> void): void;")
    @!sts_inject_into_class("""off(type: string, callback?: object): void {
        if (type === "errorOccurred") {
            this.offErrorOccurred(callback as (((data: ErrorInfo)=> void) | undefined));
        } else {
        }
    }""")

    OnError(callback: (err: @sts_type("BusinessError<void>") Opaque)=> void): void;
    OffError(): void;

    OnPlayFinishedWithStreamId(callback: (data: i32) => void): void;
    OffPlayFinishedWithStreamId();

    OnLoadComplete(callback: (data: i32) => void): void;
    OffLoadComplete();

    OnPlayFinished(callback: (data: @sts_type("undefined") Opaque) => void): void;
    OffPlayFinished();

    OnErrorOccurred(callback: (data: @sts_type("ErrorInfo") Opaque) => void): void;
    OffErrorOccurred(callback: Optional<(data: @sts_type("ErrorInfo") Opaque) => void>): void;
}
