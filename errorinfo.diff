From 4ebb8d2dd0886de7076278d4e8b4203e5e32e459 Mon Sep 17 00:00:00 2001
From: wanglingyi <wanglingyi4@huawei.com>
Date: Wed, 30 Apr 2025 17:17:47 +0800
Subject: [PATCH] TicketNo:DTS0000000000000 Description:errorinfo

Team:EMUI
Feature or Bugfix:Bugfix
Binary Source:no
PrivateCode(Yes/No):No

Change-Id: I9d5fde56bc2249a4430753229dcb60e05fd42b1b
---
 frameworks/js/media/media_enum_napi.cpp       |   7 +
 .../include/soundpool_callback_napi.h         |   6 +
 .../soundpool/src/soundpool_callback_napi.cpp | 139 ++++++++++++++++++
 .../js/soundpool/src/soundpool_napi.cpp       |   4 +-
 frameworks/native/soundpool/cache_buffer.cpp  |  46 +++---
 frameworks/native/soundpool/cache_buffer.h    |   1 +
 frameworks/native/soundpool/sound_parser.cpp  |   4 +
 frameworks/native/soundpool/stream.cpp        |   6 +
 .../native/soundpool/include/isoundpool.h     |  53 +++++++
 .../include/sound_parser_unit_test.h          |  39 +++++
 .../src/sound_parser_unit_test.cpp            |  74 ++++++++++
 11 files changed, 358 insertions(+), 21 deletions(-)
 create mode 100644 test/unittest/soundpool_test/include/sound_parser_unit_test.h
 create mode 100644 test/unittest/soundpool_test/src/sound_parser_unit_test.cpp

diff --git a/frameworks/js/media/media_enum_napi.cpp b/frameworks/js/media/media_enum_napi.cpp
index ebeaead15..6fe8e2380 100644
--- a/frameworks/js/media/media_enum_napi.cpp
+++ b/frameworks/js/media/media_enum_napi.cpp
@@ -29,6 +29,7 @@
 #include "screen_capture.h"
 #include "avscreen_capture_napi.h"
 #include "screen_capture_monitor.h"
+#include "isoundpool.h"
 
 namespace {
     constexpr OHOS::HiviewDFX::HiLogLabel LABEL = {LOG_CORE, LOG_DOMAIN_PLAYER, "MediaEnumNapi"};
@@ -426,6 +427,11 @@ static const std::vector<struct JsEnumInt> g_screenCaptureMonitorEvent = {
     { "SCREENCAPTURE_STOPPED", ScreenCaptureMonitorEvent::SCREENCAPTURE_STOPPED }
 };
 
+static const std::vector<struct JsEnumInt> g_soundpoolErrorType = {
+    { "LOAD_ERROR", ERROR_TYPE::LOAD_ERROR },
+    { "PLAY_ERROR", ERROR_TYPE::PLAY_ERROR }
+};
+
 static const std::map<std::string_view, const std::vector<struct JsEnumInt>&> g_intEnumClassMap = {
     { "AVErrorCode", g_AVErrorCode},
     { "MediaErrorCode", g_mediaErrorCode },
@@ -463,6 +469,7 @@ static const std::map<std::string_view, const std::vector<struct JsEnumInt>&> g_
     { "MetaSourceType", g_metaSourceType},
     { "ScreenCaptureEvent", g_screenCaptureMonitorEvent },
     { "AVScreenCaptureFillMode", g_screenCaptureFillMode},
+    { "ErrorType", g_soundpoolErrorType },
 };
 
 static const std::map<std::string_view, const std::vector<struct JsEnumString>&> g_stringEnumClassMap = {
diff --git a/frameworks/js/soundpool/include/soundpool_callback_napi.h b/frameworks/js/soundpool/include/soundpool_callback_napi.h
index 23a00cde0..58d4da169 100644
--- a/frameworks/js/soundpool/include/soundpool_callback_napi.h
+++ b/frameworks/js/soundpool/include/soundpool_callback_napi.h
@@ -30,6 +30,7 @@ namespace SoundPoolEvent {
     const std::string EVENT_PLAY_FINISHED = "playFinished";
     const std::string EVENT_PLAY_FINISHED_WITH_STREAM_ID = "playFinishedWithStreamId";
     const std::string EVENT_ERROR = "error";
+    const std::string EVENT_ERROR_INFO = "errorInfo";
 }
 
 class SoundPoolCallBackNapi : public ISoundPoolCallback {
@@ -40,6 +41,7 @@ public:
     void CancelCallbackReference(const std::string &name);
     void ClearCallbackReference();
     void SendErrorCallback(int32_t errCode, const std::string &msg);
+    void SendErrorInfoCallback(const Format &errorInfo);
     void SendLoadCompletedCallback(int32_t soundId);
     void SendPlayCompletedCallback(int32_t streamID);
 
@@ -47,10 +49,12 @@ protected:
     void OnLoadCompleted(int32_t soundId) override;
     void OnPlayFinished(int32_t streamID) override;
     void OnError(int32_t errorCode) override;
+    void OnErrorInfo(Format &errorInfo) override;
 
 private:
     struct SoundPoolJsCallBack {
         void RunJsErrorCallBackTask(int status, SoundPoolJsCallBack *event);
+        void RunJsErrorInfoCallBackTask(int status, SoundPoolJsCallBack *event);
         void RunJsloadCompletedCallBackTask(int status, SoundPoolJsCallBack *event);
         void RunJsplayCompletedCallBackTask(int status, SoundPoolJsCallBack *event);
         
@@ -61,8 +65,10 @@ private:
         int32_t reason = 1;
         int32_t loadSoundId = 0;
         int32_t playFinishedStreamID = 0;
+        ERROR_TYPE errorType = ERROR_TYPE::LOAD_ERROR;
     };
     void OnJsErrorCallBack(SoundPoolJsCallBack *jsCb) const;
+    void OnJsErrorInfoCallBack(SoundPoolJsCallBack *jsCb) const;
     void OnJsloadCompletedCallBack(SoundPoolJsCallBack *jsCb) const;
     void OnJsplayCompletedCallBack(SoundPoolJsCallBack *jsCb) const;
     napi_env env_ = nullptr;
diff --git a/frameworks/js/soundpool/src/soundpool_callback_napi.cpp b/frameworks/js/soundpool/src/soundpool_callback_napi.cpp
index f9a9c6e68..8770f9fd2 100644
--- a/frameworks/js/soundpool/src/soundpool_callback_napi.cpp
+++ b/frameworks/js/soundpool/src/soundpool_callback_napi.cpp
@@ -58,6 +58,33 @@ void SoundPoolCallBackNapi::OnError(int32_t errorCode)
     }
 }
 
+void SoundPoolCallBackNapi::OnErrorInfo(Format &errorInfo)
+{
+    MEDIA_LOGI("OnErrorInfo recived");
+    int32_t errorCode;
+    errorInfo.GetIntValue(SoundPoolKeys::ERROR_CODE, errorCode);
+    switch (errorCode) {
+        case MSERR_INVALID_OPERATION:
+            errorInfo.PutIntValue(SoundPoolKeys::ERROR_CODE, MSERR_EXT_API9_OPERATE_NOT_PERMIT);
+            errorInfo.PutStringValue(SoundPoolKeys::ERROR_MESSAGE,
+                "The soundpool timed out. Please confirm that the input stream is normal.");
+            break;
+        case MSERR_NO_MEMORY:
+            errorInfo.PutIntValue(SoundPoolKeys::ERROR_CODE, MSERR_EXT_API9_NO_MEMORY);
+            errorInfo.PutStringValue(SoundPoolKeys::ERROR_MESSAGE, "soundpool memery error.");
+            break;
+        case MSERR_SERVICE_DIED:
+            errorInfo.PutIntValue(SoundPoolKeys::ERROR_CODE, MSERR_EXT_API9_SERVICE_DIED);
+            errorInfo.PutStringValue(SoundPoolKeys::ERROR_MESSAGE, "releated server died");
+            break;
+        default:
+            errorInfo.PutIntValue(SoundPoolKeys::ERROR_CODE, MSERR_EXT_API9_IO);
+            errorInfo.PutStringValue(SoundPoolKeys::ERROR_MESSAGE, "IO error happened.");
+            break;
+    }
+    SendErrorInfoCallback(errorInfo);
+}
+
 void SoundPoolCallBackNapi::SaveCallbackReference(const std::string &name, std::weak_ptr<AutoRef> ref)
 {
     std::lock_guard<std::mutex> lock(mutex_);
@@ -99,6 +126,41 @@ void SoundPoolCallBackNapi::SendErrorCallback(int32_t errCode, const std::string
     return OnJsErrorCallBack(cb);
 }
 
+void SoundPoolCallBackNapi::SendErrorInfoCallback(const Format &errorInfo)
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    if (refMap_.find(SoundPoolEvent::EVENT_ERROR_INFO) == refMap_.end()) {
+        MEDIA_LOGW("can not find errorInfo callback!");
+        return;
+    }
+    SoundPoolJsCallBack *cb = new(std::nothrow) SoundPoolJsCallBack();
+    CHECK_AND_RETURN_LOG(cb != nullptr, "cb is nullptr");
+    int32_t errorCode;
+    std::string msg;
+    errorInfo.GetIntValue(SoundPoolKeys::ERROR_CODE, errorCode);
+    errorInfo.GetStringValue(SoundPoolKeys::ERROR_MESSAGE, msg);
+    if (errorInfo.ContainKey(SoundPoolKeys::STREAM_ID)) {
+        int32_t streamId;
+        errorInfo.GetIntValue(SoundPoolKeys::STREAM_ID, streamId);
+        cb->playFinishedStreamID = streamId;
+    }
+    if (errorInfo.ContainKey(SoundPoolKeys::ERROR_TYPE_FLAG)) {
+        int32_t errorType;
+        errorInfo.GetIntValue(SoundPoolKeys::ERROR_TYPE_FLAG, errorType);
+        cb->errorType = static_cast<ERROR_TYPE>(errorType);
+    }
+    if (errorInfo.ContainKey(SoundPoolKeys::SOUND_ID)) {
+        int32_t soundId;
+        errorInfo.GetIntValue(SoundPoolKeys::SOUND_ID, soundId);
+        cb->loadSoundId = soundId;
+    }
+    cb->autoRef = refMap_.at(SoundPoolEvent::EVENT_ERROR_INFO);
+    cb->callbackName = SoundPoolEvent::EVENT_ERROR_INFO;
+    cb->errorCode = errorCode;
+    cb->errorMsg = msg;
+    return OnJsErrorInfoCallBack(cb);
+}
+
 void SoundPoolCallBackNapi::SendLoadCompletedCallback(int32_t soundId)
 {
     std::lock_guard<std::mutex> lock(mutex_);
@@ -181,6 +243,39 @@ void SoundPoolCallBackNapi::OnJsErrorCallBack(SoundPoolJsCallBack *jsCb) const
     CANCEL_SCOPE_EXIT_GUARD(1);
 }
 
+void SoundPoolCallBackNapi::OnJsErrorInfoCallBack(SoundPoolJsCallBack *jsCb) const
+{
+    ON_SCOPE_EXIT(0) {
+        delete jsCb;
+    };
+    uv_loop_s *loop = nullptr;
+    napi_get_uv_event_loop(env_, &loop);
+    CHECK_AND_RETURN_LOG(loop != nullptr, "Fail to get uv event loop");
+
+    uv_work_t *work = new(std::nothrow) uv_work_t;
+    CHECK_AND_RETURN_LOG(work != nullptr, "fail to new uv_work_t");
+    ON_SCOPE_EXIT(1) {
+        delete work;
+    };
+    work->data = reinterpret_cast<void *>(jsCb);
+    // async callback, jsWork and jsWork->data should be heap object.
+    int ret = uv_queue_work_with_qos(loop, work, [] (uv_work_t *work) {
+        MEDIA_LOGD("OnJsErrorInfoCallBack uv_queue_work_with_qos");
+    }, [] (uv_work_t *work, int status) {
+        // Js Thread
+        CHECK_AND_RETURN_LOG(work != nullptr, "work is nullptr");
+        SoundPoolJsCallBack *event = reinterpret_cast<SoundPoolJsCallBack *>(work->data);
+        event->RunJsErrorInfoCallBackTask(status, event);
+        delete event;
+        delete work;
+    }, uv_qos_user_initiated);
+    if (ret != 0) {
+        MEDIA_LOGI("fail to uv_queue_work_with_qos task");
+    }
+    CANCEL_SCOPE_EXIT_GUARD(0);
+    CANCEL_SCOPE_EXIT_GUARD(1);
+}
+
 void SoundPoolCallBackNapi::SoundPoolJsCallBack::RunJsErrorCallBackTask(int status, SoundPoolJsCallBack *event)
 {
     std::string request = event->callbackName;
@@ -218,6 +313,50 @@ void SoundPoolCallBackNapi::SoundPoolJsCallBack::RunJsErrorCallBackTask(int stat
     } while (0);
 }
 
+void SoundPoolCallBackNapi::SoundPoolJsCallBack::RunJsErrorInfoCallBackTask(int status, SoundPoolJsCallBack *event)
+{
+    std::string request = event->callbackName;
+    do {
+        MEDIA_LOGI("errorInfoCallback event: errorMsg %{public}s, errorCode %{public}d, soundId %{public}d,"
+            "streamId %{public}d", event->errorMsg.c_str(), event->errorCode, event->loadSoundId,
+            event->playFinishedStreamID);
+        CHECK_AND_BREAK_LOG(status != UV_ECANCELED, "%{public}s canceled", request.c_str());
+        std::shared_ptr<AutoRef> ref = event->autoRef.lock();
+        CHECK_AND_BREAK_LOG(ref != nullptr, "%{public}s AutoRef is nullptr", request.c_str());
+        napi_handle_scope scope = nullptr;
+        napi_open_handle_scope(ref->env_, &scope);
+        CHECK_AND_BREAK_LOG(scope != nullptr, "%{public}s scope is nullptr", request.c_str());
+        ON_SCOPE_EXIT(0) {
+            napi_close_handle_scope(ref->env_, scope);
+        };
+        napi_value jsCallback = nullptr;
+        napi_status nstatus = napi_get_reference_value(ref->env_, ref->cb_, &jsCallback);
+        CHECK_AND_BREAK_LOG(nstatus == napi_ok && jsCallback != nullptr, "%{public}s get reference value fail",
+            request.c_str());
+        constexpr size_t argCount = 1;
+        napi_value args[argCount] = {};
+        napi_create_object(ref->env_, &args[0]);
+
+        napi_value errCode = nullptr;
+        status = CommonNapi::CreateError(ref->env_, event->errorCode, event->errorMsg, errCode);
+        CHECK_AND_RETURN_LOG(status == napi_ok && errCode != nullptr,
+            " fail to convert to errorCode");
+        napi_set_named_property(ref->env_, args[0], "errorCode", errCode);
+        bool res = CommonNapi::SetPropertyInt32(ref->env_, args[0], "errorType", event->errorType);
+        CHECK_AND_RETURN_LOG(res, " fail to convert to errorType");
+        res = CommonNapi::SetPropertyInt32(ref->env_, args[0], "soundId", event->loadSoundId);
+        CHECK_AND_RETURN_LOG(res, " fail to convert to soundId");
+        if (event->playFinishedStreamID > 0) {
+            res = CommonNapi::SetPropertyInt32(ref->env_, args[0], "streamId", event->playFinishedStreamID);
+            CHECK_AND_RETURN_LOG(res, " fail to convert to streamId");
+        }
+
+        napi_value result = nullptr;
+        nstatus = napi_call_function(ref->env_, nullptr, jsCallback, argCount, args, &result);
+        CHECK_AND_BREAK_LOG(nstatus == napi_ok, "%{public}s fail to napi call function", request.c_str());
+    } while (0);
+}
+
 void SoundPoolCallBackNapi::OnJsloadCompletedCallBack(SoundPoolJsCallBack *jsCb) const
 {
     ON_SCOPE_EXIT(0) {
diff --git a/frameworks/js/soundpool/src/soundpool_napi.cpp b/frameworks/js/soundpool/src/soundpool_napi.cpp
index 66471182d..2a57a74f2 100644
--- a/frameworks/js/soundpool/src/soundpool_napi.cpp
+++ b/frameworks/js/soundpool/src/soundpool_napi.cpp
@@ -697,7 +697,7 @@ napi_value SoundPoolNapi::JsSetOnCallback(napi_env env, napi_callback_info info)
     MEDIA_LOGI("set callbackName: %{public}s", callbackName.c_str());
     if (callbackName != SoundPoolEvent::EVENT_LOAD_COMPLETED && callbackName != SoundPoolEvent::EVENT_PLAY_FINISHED &&
         callbackName != SoundPoolEvent::EVENT_PLAY_FINISHED_WITH_STREAM_ID &&
-        callbackName != SoundPoolEvent::EVENT_ERROR) {
+        callbackName != SoundPoolEvent::EVENT_ERROR && callbackName != SoundPoolEvent::EVENT_ERROR_INFO) {
         soundPoolNapi->ErrorCallback(MSERR_INVALID_VAL, "SetEventCallback");
         return result;
     }
@@ -734,7 +734,7 @@ napi_value SoundPoolNapi::JsClearOnCallback(napi_env env, napi_callback_info inf
     std::string callbackName = CommonNapi::GetStringArgument(env, args[0]);
     if (callbackName != SoundPoolEvent::EVENT_LOAD_COMPLETED && callbackName != SoundPoolEvent::EVENT_PLAY_FINISHED &&
         callbackName != SoundPoolEvent::EVENT_PLAY_FINISHED_WITH_STREAM_ID &&
-        callbackName != SoundPoolEvent::EVENT_ERROR) {
+        callbackName != SoundPoolEvent::EVENT_ERROR && callbackName != SoundPoolEvent::EVENT_ERROR_INFO) {
         soundPoolNapi->ErrorCallback(MSERR_INVALID_VAL, "CancelEventCallback");
         return result;
     }
diff --git a/frameworks/native/soundpool/cache_buffer.cpp b/frameworks/native/soundpool/cache_buffer.cpp
index 3977cd758..f5bf4a9f4 100644
--- a/frameworks/native/soundpool/cache_buffer.cpp
+++ b/frameworks/native/soundpool/cache_buffer.cpp
@@ -255,25 +255,7 @@ int32_t CacheBuffer::DoPlay(const int32_t streamID)
         });
     if (!audioRenderer_->Start()) {
         soundPoolXCollie.CancelXCollieTimer();
-        OHOS::AudioStandard::RendererState state = audioRenderer_->GetStatus();
-        if (state == OHOS::AudioStandard::RendererState::RENDERER_RUNNING) {
-            MEDIA_LOGI("CacheBuffer::DoPlay audioRenderer has started, streamID:%{public}d", streamID);
-            isRunning_.store(true);
-            if (callback_ != nullptr) {
-                MEDIA_LOGI("CacheBuffer::DoPlay callback_ OnPlayFinished, streamID:%{public}d", streamID);
-                callback_->OnPlayFinished(streamID_);
-            }
-            return MSERR_OK;
-        } else {
-            MEDIA_LOGE("CacheBuffer::DoPlay audioRenderer start failed, streamID:%{public}d", streamID);
-            isRunning_.store(false);
-            if (callback_ != nullptr) {
-                MEDIA_LOGI("CacheBuffer::DoPlay failed, call callback, streamID:%{public}d", streamID);
-                callback_->OnError(MSERR_INVALID_VAL);
-            }
-            if (cacheBufferCallback_ != nullptr) cacheBufferCallback_->OnError(MSERR_INVALID_VAL);
-            return MSERR_INVALID_VAL;
-        }
+        return DoPlayHelper(streamID);
     } else {
         soundPoolXCollie.CancelXCollieTimer();
     }
@@ -281,6 +263,32 @@ int32_t CacheBuffer::DoPlay(const int32_t streamID)
     return MSERR_OK;
 }
 
+int32_t CacheBuffer::DoPlayHelper(const int32_t streamID)
+{
+    OHOS::AudioStandard::RendererState state = audioRenderer_->GetStatus();
+    if (state == OHOS::AudioStandard::RendererState::RENDERER_RUNNING) {
+        MEDIA_LOGI("CacheBuffer::DoPlay audioRenderer has started, streamID:%{public}d", streamID);
+        isRunning_.store(true);
+        if (callback_ != nullptr) {
+            MEDIA_LOGI("CacheBuffer::DoPlay callback_ OnPlayFinished, streamID:%{public}d", streamID);
+            callback_->OnPlayFinished(streamID_);
+        }
+        return MSERR_OK;
+    } else {
+        MEDIA_LOGE("CacheBuffer::DoPlay audioRenderer start failed, streamID:%{public}d", streamID);
+        isRunning_.store(false);
+        if (callback_ != nullptr) {
+            MEDIA_LOGI("CacheBuffer::DoPlay failed, call callback, streamID:%{public}d", streamID);
+            callback_->OnError(MSERR_INVALID_VAL);
+            SoundPoolUtils::ErrorInfo errorInfo{MSERR_INVALID_VAL, soundID_,
+                streamID_, ERROR_TYPE::PLAY_ERROR, callback_};
+            SoundPoolUtils::SendErrorInfo(errorInfo);
+        }
+        if (cacheBufferCallback_ != nullptr) cacheBufferCallback_->OnError(MSERR_INVALID_VAL);
+        return MSERR_INVALID_VAL;
+    }
+}
+
 void CacheBuffer::DealPlayParamsBeforePlay(const PlayParams &playParams)
 {
     audioRenderer_->SetOffloadAllowed(false);
diff --git a/frameworks/native/soundpool/cache_buffer.h b/frameworks/native/soundpool/cache_buffer.h
index ae8a5ed24..013017105 100644
--- a/frameworks/native/soundpool/cache_buffer.h
+++ b/frameworks/native/soundpool/cache_buffer.h
@@ -109,6 +109,7 @@ private:
     static AudioStandard::AudioRendererRate CheckAndAlignRendererRate(const int32_t rate);
     void DealWriteData(size_t length);
     bool IsAudioRendererCanMix(const AudioStandard::AudioRendererInfo &audioRendererInfo);
+    int32_t DoPlayHelper(const int32_t streamID);
     int32_t PreparePlayInner(const AudioStandard::AudioRendererInfo &audioRendererInfo,
         const PlayParams &playParams);
     int32_t GetGlobalId(int32_t soundID);
diff --git a/frameworks/native/soundpool/sound_parser.cpp b/frameworks/native/soundpool/sound_parser.cpp
index 051956d65..931f474fa 100644
--- a/frameworks/native/soundpool/sound_parser.cpp
+++ b/frameworks/native/soundpool/sound_parser.cpp
@@ -74,6 +74,8 @@ int32_t SoundParser::DoParser()
     if (result != MSERR_OK && callback_ != nullptr) {
         MEDIA_LOGI("DoDemuxer failed, call callback");
         callback_->OnError(MSERR_UNSUPPORT_FILE);
+        SoundPoolUtils::ErrorInfo errorInfo{MSERR_UNSUPPORT_FILE, soundID_, 0, ERROR_TYPE::LOAD_ERROR, callback_};
+        SoundPoolUtils::SendErrorInfo(errorInfo);
         return MSERR_INVALID_VAL;
     } else if (result != MSERR_OK && callback_ == nullptr) {
         MEDIA_LOGI("DoDemuxer failed, callback is nullptr");
@@ -83,6 +85,8 @@ int32_t SoundParser::DoParser()
     if (result != MSERR_OK && callback_ != nullptr) {
         MEDIA_LOGI("DoDecode failed, call callback");
         callback_->OnError(MSERR_UNSUPPORT_FILE);
+        SoundPoolUtils::ErrorInfo errorInfo{MSERR_UNSUPPORT_FILE, soundID_, 0, ERROR_TYPE::LOAD_ERROR, callback_};
+        SoundPoolUtils::SendErrorInfo(errorInfo);
         return MSERR_INVALID_VAL;
     } else if (result != MSERR_OK && callback_ == nullptr) {
         MEDIA_LOGI("DoDecode failed, callback is nullptr");
diff --git a/frameworks/native/soundpool/stream.cpp b/frameworks/native/soundpool/stream.cpp
index 46092d589..0bfbedb64 100644
--- a/frameworks/native/soundpool/stream.cpp
+++ b/frameworks/native/soundpool/stream.cpp
@@ -256,6 +256,9 @@ int32_t Stream::DoPlay()
         MEDIA_LOGE("Stream::DoPlay failed, cacheData or audioRender nullptr, streamID:%{public}d", streamID_);
         if (callback_ != nullptr) {
             callback_->OnError(MSERR_INVALID_VAL);
+            SoundPoolUtils::ErrorInfo errorInfo{MSERR_INVALID_VAL, soundID_,
+                streamID_, ERROR_TYPE::PLAY_ERROR, callback_};
+            SoundPoolUtils::SendErrorInfo(errorInfo);
         }
         if (streamCallback_ != nullptr) {
             streamCallback_->OnError(MSERR_INVALID_VAL);
@@ -280,6 +283,9 @@ int32_t Stream::DoPlay()
         if (callback_ != nullptr) {
             MEDIA_LOGE("Stream::DoPlay failed, call callback, streamID:%{public}d", streamID_);
             callback_->OnError(MSERR_INVALID_VAL);
+            SoundPoolUtils::ErrorInfo errorInfo{MSERR_INVALID_VAL, soundID_,
+                streamID_, ERROR_TYPE::PLAY_ERROR, callback_};
+            SoundPoolUtils::SendErrorInfo(errorInfo);
         }
         if (streamCallback_ != nullptr) {
             streamCallback_->OnError(MSERR_INVALID_VAL);
diff --git a/interfaces/inner_api/native/soundpool/include/isoundpool.h b/interfaces/inner_api/native/soundpool/include/isoundpool.h
index 08eac5c5d..ded1e094b 100644
--- a/interfaces/inner_api/native/soundpool/include/isoundpool.h
+++ b/interfaces/inner_api/native/soundpool/include/isoundpool.h
@@ -18,6 +18,8 @@
 
 #include <string>
 #include "audio_info.h"
+#include "meta/format.h"
+#include "media_errors.h"
 
 namespace OHOS {
 namespace Media {
@@ -197,6 +199,18 @@ public:
      * @version 1.0
      */
     virtual void OnError(int32_t errorCode) = 0;
+
+    /**
+     * @brief Register listens for sound play error events.
+     *
+     * @param errorInfo errorInfo
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual void OnErrorInfo(Format &errorInfo)
+    {
+        (void)errorInfo;
+    }
 };
 
 class ISoundPoolFrameWriteCallback {
@@ -229,6 +243,45 @@ private:
     SoundPoolFactory() = default;
     ~SoundPoolFactory() = default;
 };
+
+class SoundPoolKeys {
+public:
+    static constexpr std::string_view ERROR_CODE = "error_code";
+    static constexpr std::string_view ERROR_MESSAGE = "error_message";
+    static constexpr std::string_view ERROR_TYPE_FLAG = "error_type_flag";
+    static constexpr std::string_view SOUND_ID = "sound_id";
+    static constexpr std::string_view STREAM_ID = "stream_id";
+};
+
+enum ERROR_TYPE : int32_t {
+    LOAD_ERROR = 1,
+    PLAY_ERROR = 2
+};
+
+class SoundPoolUtils {
+public:
+    struct ErrorInfo {
+        int32_t errorCode = MSERR_INVALID_VAL;
+        int32_t soundId = 0;
+        int32_t streamId = 0;
+        ERROR_TYPE errorType = ERROR_TYPE::LOAD_ERROR;
+        std::shared_ptr<ISoundPoolCallback> callback = nullptr;
+    };
+    static void SendErrorInfo(const ErrorInfo& errorInfo)
+    {
+        Format format;
+        format.PutIntValue(SoundPoolKeys::ERROR_CODE, errorInfo.errorCode);
+        format.PutIntValue(SoundPoolKeys::ERROR_TYPE_FLAG, errorInfo.errorType);
+        format.PutIntValue(SoundPoolKeys::SOUND_ID, errorInfo.soundId);
+        if (errorInfo.streamId > 0) {
+            format.PutIntValue(SoundPoolKeys::STREAM_ID, errorInfo.streamId);
+        }
+        if (errorInfo.callback != nullptr) {
+            errorInfo.callback->OnErrorInfo(format);
+        }
+    }
+};
+
 } // namespace Media
 } // namespace OHOS
 #endif // ISOUNDPOOL_H
diff --git a/test/unittest/soundpool_test/include/sound_parser_unit_test.h b/test/unittest/soundpool_test/include/sound_parser_unit_test.h
new file mode 100644
index 000000000..93281f84c
--- /dev/null
+++ b/test/unittest/soundpool_test/include/sound_parser_unit_test.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef SOUND_PARSER_UNIT_TEST_H
+#define SOUND_PARSER_UNIT_TEST_H
+
+#include "gtest/gtest.h"
+#include "sound_id_manager.h"
+
+namespace OHOS {
+namespace Media {
+class SoundParseUnitTest : public testing::Test {
+public:
+    // SetUpTestCase: Called before all test cases
+    static void SetUpTestCase(void);
+    // TearDownTestCase: Called after all test case
+    static void TearDownTestCase(void);
+    // SetUp: Called before each test cases
+    void SetUp(void);
+    // TearDown: Called after each test cases
+    void TearDown(void);
+
+protected:
+    std::shared_ptr<SoundParse> soundParser_ = nullptr;
+};
+}  // namespace Media
+}  // namespace OHOS
+#endif
\ No newline at end of file
diff --git a/test/unittest/soundpool_test/src/sound_parser_unit_test.cpp b/test/unittest/soundpool_test/src/sound_parser_unit_test.cpp
new file mode 100644
index 000000000..f124209d3
--- /dev/null
+++ b/test/unittest/soundpool_test/src/sound_parser_unit_test.cpp
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "sound_parser_unit_test.h"
+#include "media_errors.h"
+#include "sound_parser.h"
+
+using namespace OHOS;
+using namespace OHOS::Media;
+using namespace testing::ext;
+using namespace std;
+
+const int32_t MAX_STREAMS = 3;
+const int32_t BEGIN_NUM = 0;
+const int32_t STREAM_ID_BEGIN = 1;
+
+namespace {
+constexpr OHOS::HiviewDFX::HiLogLabel LABEL = {LOG_CORE, LOG_DOMAIN_SOUNDPOOL, "SoundParseUnitTest"};
+}
+
+namespace OHOS {
+namespace Media {
+void SoundParseUnitTest::SetUpTestCase(void)
+{}
+
+void SoundParseUnitTest::TearDownTestCase(void)
+{
+    std::cout << "sleep one second to protect PlayerEngine safely exit." << endl;
+    sleep(1);  // let PlayEngine safe exit.
+}
+
+void SoundParseUnitTest::SetUp(void)
+{
+    soundParser_ = std::make_shared<SoundParser>();
+}
+
+void SoundParseUnitTest::TearDown(void)
+{
+    if (soundParser_ != nullptr) {
+        soundParser_.reset();
+    }
+}
+
+/**
+ * @tc.name: doparse failed
+ * @tc.desc: function test DoParser
+ * @tc.type: FUNC
+ * @tc.require:
+ */
+HWTEST_F(SoundParseUnitTest, doParser_function_001, TestSize.Level2)
+{
+    MEDIA_LOGI("doParser_function_001 before");
+    soundParser_->source_ = std::make_shared<MediaAVCodec::AVSource>();
+    soundParser_->demuxer_ = std::make_shared<MediaAVCodec::AVDemuxer>();
+    soundParser_->trackFormat_ = nullptr;
+    soundParser_->callback_ = std::make_shared<ISoundPoolCallback>();
+    EXPECT_EQ(MSERR_INVALID_VAL, soundParser_->DoParse());
+    MEDIA_LOGI("doParser_function_001 after");
+}
+
+}  // namespace Media
+}  // namespace OHOS
\ No newline at end of file
-- 
2.45.2.huawei.8
